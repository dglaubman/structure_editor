// Generated by CoffeeScript 1.6.3
(function() {
  var getTicket, messageHandler, root,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.Controller = (function() {
    var comm, format, leaves, log, positions, tracks;

    log = comm = leaves = positions = void 0;

    function Controller(console) {
      this.start = __bind(this.start, this);
      log = console;
    }

    Controller.prototype.start = function(callback) {
      var _this = this;
      return getTicket(function(ticket) {
        comm = new Communicator(log, messageHandler(_this));
        return comm.connect(config, ticket, callback);
      });
    };

    Controller.prototype.subscribe = function(graph) {
      return comm.startSubscription(graph);
    };

    Controller.prototype.stat = function(track, position, loss) {
      var _ref;
      log.log("" + position + ": " + loss);
      if (track !== this.track) {
        return log.write("error: stat expected track " + this.track + ", rec'd " + track);
      }
      return (_ref = positions[position]) != null ? _ref.text(format(loss)) : void 0;
    };

    Controller.prototype.ready = function(route, track) {
      var nodes;
      log.write("" + route + " on " + track);
      nodes = graph().nodes;
      leaves = graph().initial;
      positions = tracks[track] || (tracks[track] = {});
      d3.selectAll(".stat text").each(function(d, i) {
        var initial, key, x;
        x = d3.select(this);
        key = nodes[i].value.label;
        initial = leaves[key] || "";
        x.text(format(initial));
        return positions[encode(key)] = x;
      });
      return this.track = track;
    };

    Controller.prototype.run = function(numIter) {
      var _this = this;
      return d3.entries(leaves).forEach(function(entry) {
        return comm.startFeed(entry.key, _this.track, entry.value, numIter);
      });
    };

    Controller.prototype.stopped = function(type, name) {
      return log.write("recd stopped signal for " + type + " " + name);
    };

    tracks = {};

    leaves = void 0;

    format = function(number) {
      switch (false) {
        case !(number >= 1000000000):
          return "" + ((number / 1000000000).toFixed(2)) + "B";
        case !(number >= 1000000):
          return "" + ((number / 1000000).toFixed(2)) + "M";
        case !(number >= 1000):
          return "" + ((number / 1000).toFixed(1)) + "K";
        default:
          return number;
      }
    };

    return Controller;

  })();

  messageHandler = function(controller) {
    return function(m) {
      var body, topic;
      topic = m.args.routingKey;
      body = m.body.getString(Charset.UTF8);
      switch (m.args.exchange) {
        case config.serverX:
          return serverDispatcher(controller, body);
      }
    };
  };

  getTicket = function(callback) {
    return d3.text('./ts', function(err, ticket) {
      if (err) {
        return log.write(err);
      } else {
        return callback(ticket);
      }
    });
  };

}).call(this);
